Q.1 //You are climbing a staircase. It takes n steps to reach the top.
//Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
package geekswork;

 class solution  {
	public int fact(int n)                             //this function will return factorial of a number to the calling function
	{int factorial=1;
		for (int i=1;i<=n;i++)
		{
			factorial=factorial*i;
		}
		return factorial;
	}
	}
class geekwork10 {
    public static void main(String args[]) {
        int c=0,total=0; int n=5;
       solution ob=new solution();
        for(int i=0;i<=n;i++)
        {
            for(int j=0;j<=n;j++)
            {
                total=(1*i)+(2*j);                //Condition to check the no of ways we can climb to given no of step using step size of 1&2 without permutation
                if (total==n)
                {
                    
                    c=c+((ob.fact(i+j))/(ob.fact(i)*ob.fact(j)));             //this is used to calculate total ways to clim up with permulation
                    continue;
                }
                     
            }
        }
        System.out.println(c);
    }
}


Q.2//Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

//The number of elements initialized in nums1 and nums2 are m and n respectively. 
//You may assume that nums1 has a size equal to m + n such that it has enough space to hold additional elements from nums2.

class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int temp=0;
        for(int i=0;i<m+n;i++)                    //this loop is used for merging both the array
        {
            if(i>=m)
            {
                nums1[i]=nums2[i-m];
            }
            else
                nums1[i]=nums1[i];
        }
        for(int j=0;j<m+n;j++)                   //these two loops are used for sorting
        {
            for(int k=0;k<m+n-1;k++)
            {
                if(nums1[k]>nums1[k+1])           //Swapping the two number
                {
                    temp=nums1[k];
                nums1[k]=nums1[k+1];
                nums1[k+1]=temp;
                }
            }
        }
        
    }
}


Q.3    Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, 
which minimizes thesum of all numbers along its path.Note: You can only move either down or 
right at any point in time.

class Solution {
    public int minPathSum(int[][] grid) {                          //We have followed bottom to up approach of dyanimic programming
        
        int rows = grid.length;                                        //Calculate size of grid
        int cols = grid[0].length;
        int dp[][] = new int[rows][cols];
        
        for(int i = rows-1;i>=0;i--)        
        {
            for(int j = cols-1;j>=0;j--)
            {
                if(i==rows-1 && j == cols-1)                            //element is last element of grid
                {
                    dp[i][j] = grid[i][j];
                }
				else if(i==rows-1)                         // element belongs to last row
                {
                    dp[i][j] = dp[i][j+1] + grid[i][j];
                } 
				else if(j == cols-1)                         //elements belongs to last columns
                {
                    dp[i][j] = dp[i+1][j] + grid[i][j];
                } 
                else                                                                    //it will choose the min value
                {
                    dp[i][j] =  grid[i][j]  + Math.min(dp[i][j+1], dp[i+1][j]);
                }
            }
        }
        
        return dp[0][0];                                                     //It will contain minsum of path that can be followed
        
    }
}



Q.4  Given an m x n board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially 
adjacent cells, where "adjacent" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

class Solution {
    public boolean exist(char[][] board, String word) // Main method
{
        for(int i = 0; i < board.length; i++)  // Iterate through the matrix, while doing so, call the support method so it will do the calculations.
        {
            for(int j = 0; j < board[0].length; j++) 
            {                
                if(helper(board, i, j, word, 0))// Here the main method gets the results form the support method.
                {
                   return true;
                }
            }
        }
        return false;
    }
    
    private boolean helper(char[][] board, int x, int y, String word, int end) // Support method.
    {     
        if(x < 0 || board.length-1 < x || y < 0 || board[0].length-1 < y || board[x][y] == 'x' || word.charAt(end) != board[x][y]) 
	// Check if we are in the boundaries, or the spot has been visited or that the current letter do not match to the letter in the matrix.
	    {
            return false;
        }
        
        if(end == word.length()-1) // If we have reached the end of the given word, we found it in the matrix.
        {
            return true;
        }
          
        char temp = board[x][y]; // Make a copy of the current spot that we are in.
			board[x][y] = 'x'; 
			
			// Overwrite the current spot so that we will know that we have been here before (for the rest of the current iteration).
           
        boolean up = helper(board, x-1, y, word, end+1);       // Options of traversing the matrix.
        boolean down = helper(board, x+1, y, word, end+1);
        boolean left = helper(board, x, y-1, word, end+1);
        boolean right = helper(board, x, y+1, word, end+1);
        
        if(up || down || left || right) // If the options are valid, return true.
        {
            return true;
        }
        else
        {
             board[x][y] = temp; // Else overwrite the current spot with the copy of the original value for the next iteration.
             return false;
		}
			 
         
 }
}


Q.5  Given an array of non-negative integers nums, you are initially positioned at the first index of the array.
      Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index.
      
      class Solution {
    public boolean canJump(int[] nums) {
        
        int midx=0;
        for(int i=0;i<nums.length;i++)
        {
            if(midx<i)                                //this is condition to check whether at particular index we will be able to reach or not
                return false;
            midx = Math.max(midx,i+nums[i]);          // at maximum index where we can reach
        }
        return true;
    }
}
